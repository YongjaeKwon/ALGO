'''
0 + 1
1 + 1

맨 뒤의 비트가 0이면 인접한 비트의수 증가 x
맨 뒤의 비트가 1이면 인접한 비트의수 증가 o


dp[n][k][1] = dp[n - 1][k - 1][1] + dp[n - 1][k][0]
=> k가 0일 경우를 고려해야함
=> k가 0일 경우 뒤에 1을 붙이면 기존의 0으로 끝나던 갯수와 동일
dp[n][k][0] = dp[n - 1][k][0] + dp[n - 1][k][1]
'''

import sys
input = sys.stdin.readline

dp = [[[0 for _ in range(2)] for _ in range(110)] for _ in range(110)]
# 1자리수의 0개의 연속 비트를 가진 0과 1로 끝나는 수열의 개수 => 각각 0,1로 1개
dp[1][0][0] = 1
dp[1][0][1] = 1

for k in range(101):
  for n in range(2,101):
    # 마지막에 있던 비트에 1을 더한다.
    if k != 0:
      # 연속된 비트수가 0이 아니라면
      # 1로 끝나는 k-1개에서 + 1을 하거나, 이미 k개를 가지고 있는 0으로 끝나는 비트의 경우의 수를 더한다.
      dp[n][k][1] = dp[n-1][k-1][1] + dp[n-1][k][0]
    else:
      # 연속된 비트 수가 0개라면 뒤에 1을 붙여도, n-1 자리수의 0개의 연속된 비트의수 중에서 0으로 끝나는 경우의수에 1을 더해도 경우의 수는 같다.
      dp[n][0][1] = dp[n-1][0][0]

    # 이전에 0으로 끝나던 비트와 1로 끝나던 비트의 숫자에 0을 더한다. => n자리수의 k개의 연속비트를 가진 0으로 끝나는 수열의 개수
    dp[n][k][0] = dp[n-1][k][0] + dp[n-1][k][1]


T = int(input())
for i in range(T):
  n, k = map(int,input().split())
  answer = ''
  # k개의 연속된 비트를 가진 0으로 끝나는 비트의 경우의 수 + 1로 끝나는 비트의 경우의 수
  answer += str(dp[n][k][0] + dp[n][k][1])
  print(answer)