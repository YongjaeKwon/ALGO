'''
편의점2를 활용한 문제.
플레5의 문제이지만 쫄면 안된다.

풀이 방법 (완전탐색)
1. 모든 경우의 수에 대해 다 편의점2
=> nC1 + nC2 + nC3 + ... + nCn
=> 2^50 번을 탐색 하기 떄문에 시간 초과

2. 모든 점에 대해 다 편의점2
=> 최대 1000000 * 1000000 탐색하기 떄문에 시간 초과

=>? 어떻게 해야할까

두 방법 모두 무의미한 방식이 아니다.
점의 갯수가 적었다면 1번 방식 / 좌표의 범위가 작았다면 2번 방식이 해결책이 될 수 있음.

=> 탐색 횟수를 줄여보자 (최적화)

1. 탐색 범위 밖의 경우는 탐색하지 않는다.
=> 만약 좌표의 위치가 크게 분산되어 있을 경우에는 의미가 없을 수 있음. (Outlier) 크게 범위가 튀어버린 경우가 존재할 수 있기 때문에 이 방법은 적절하지 않다. 

2. 탐색할 점 조합 / 좌표의 갯수를 줄인다.
=> 점 조합의 경우에는 마땅한 방법이 없다.
=> 좌표의 갯수를 줄여보도록 한다.

=> 최적의 좌표가 나오는 값들은 여러개 이지만, 항상 점들간의 교점에서 등장한다.

점의 갯수가 홀수일 경우.
=> x,y가 각각 중간값이므로 최정의 해는 교점에서 등장하게 된다.

점의 갯수가 짝수일 경우.
=> 교점의 변을 보면 된다.
=> 사각형 범위 안에서는 어디서든 동일하다. 점을 찾는 것이 아닌 '거리'를 묻고 있기 떄문에.

각 좌표에 대하여 1~N개 (k개)의 좌표를 한 지점으로 모이게 하려면 몇 번 움직이게 해야하는가 묻는 문제이다.
'''

import sys
input = sys.stdin.readline

N = int(input())
dots = []
X = []
Y = []

for i in range(N):
  x,y = map(int,input().split())
  dots.append((x,y)), X.append(x), Y.append(y)

# 우리가 모을 수 있는 점들의 위치
X = list(set(X))
Y = list(set(Y))

# 정답을 출력할 배열
answer = [sys.maxsize] * N 

# 모을 수 있는 모든 점들의 위치에 대해서
for i in X:
  for j in Y:
    # 각 좌표들의 거리를 계산할 것이다.
    distance = []
    for dx, dy in dots:
      temp = abs(i - dx) + abs(j - dy)
      distance.append(temp)
    # 우리가 구하고자 하는 것은 갯수에 따른 최소 거리이기 때문에 거리들을 정렬
    distance.sort()

    # 이제 거리를 계산해서 계속해서 최소값으로 갱신한다. (갯수에 따른 정답을 갱신할 것이 필요함. 위에 answer 배열을 추가한다.)
    # 1~N개 만큼의 거리들을 구하며 갱신
    temp = 0
    for k in range(N):
      temp += distance[k]
      answer[k] = min(temp, answer[k])
        
print(*answer)

'''
i, j 같은 변수들 다 독립적으로 쓰자...
디버깅하는데 오래 걸렸다...
'''